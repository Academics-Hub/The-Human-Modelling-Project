{"path":".obsidian/plugins/text-extractor/cache/89ad527cb60c54782224cbf6db2977ca.json","text":"Imaging processing of blood smears and subsequent identification of malaria infected cells ELEN3008 - Biomedical Measurement, Instrumentation and Imaging : Assignment (imaging) JONATHAN FALLER (2432985) School of Electrical & Information Engineering University of the Witwatersrand Johannesburg, South Africa I. Introduction T HIS assignment [1] consisted of using various image processing techniques to identify which blood cells in blood smears are infected with malaria. It was made up of a theory component (questions surrounding image processing), and a practical component (the actual image processing). This report will answer the theory questions, and subsequently outline the approach to the practical component, before providing the found solutions and ex- plaining it. II. Theory A. Briefly explain the following image representation terms: RGB, HSV, Binary image, Greyscale image and Indexed image. • RGB – The Red, Green, Blue colour model, where the colours (in the form of light) are added to formed different mixes, thereby producing differ- ent colours in the visible spectrum. The other way to think of it is that different intensities of the 3 lights create a different visible output. [2] • HSV – The Hue, Saturation, Value colour model. Hue is the colour itself. Saturation refers to the density of the light. Value (sometimes referred to as intensity) indicates the brightness of the light. This colour model is viewed as more natural to how the human eye perceives colour. [3] • Binary image – Images that are represented by pixel values 0 (white) and 255(black), the equivalent of 0 and 1 in a binary number. They make processing of an image where you require only the silhouette much simpler. [4] • Grey scale image – An image in which each pixel is given a value from 0-255. This value represents the intensity of light from 0 (white) to 255 (black). Therefore the image is depicted in shades of grey. [5] • Indexed image – In an indexed image you create a colour map of all the different colours in the image in RGB format - this is stored in an array. You then create an image matrix, which is a matrix where each element in the matrix represents a pixel in the image and you give each element a value that points to the relevant colour in the colour map array. [6] B. List instances when each of these image representations (binary, grey scale and indexed) may be used. • Binary image – Identifying the orientation of objects, for instance if objects on a conveyor belt are laying in the correct direction for further processing • Grey scale image – In an instance where image segmentation is de- sirable, such as object detection, a single-layered grey scale image is much easier to process than an RGB or HSV image, both of with add layers of complexity. • Indexed image – Indexing an image allows us to reduce its size, making it easier to store and faster to download- /upload. C. What does an image’s licensing details mean in terms of reusing the image? The image license determines how it can be reused. There are several types of license: [7] • Rights-managed – Dictates specifics as to how the image may be used, set by the licensor to the licensee. • Royalty-free – future users are free to use the image without giving the owner any royalties for its use, but may sometimes require a one time fee on initial purchase. • Creative Commons – These range from releasing the image into the public domain, to allowing the user to use the image in a commercial setting. D. Explain the following terms: image histogram, his- togram equalisation and thresholding. • Image histogram [8] – An image histogram is a tonal representation of the image by plotting the number of pixels at each tone vs. the tonal (or brightness) variation • Histogram equalisation [9] – A technique used to adjust the contrast of the image based on the image histogram. It evenly distributes the varies intensities of light. It is a useful technique in dealing with over or under exposure of an image. • Thresholding [10] – This is the simplest way of segmenting an image, reducing grey scale to binary images. Essentially each pixel is compared to a set threshold inten- sity. If the pixel has a higher value than the threshold it is given a value of 255 (black), and if it is under the threshold, it is given a value of 0 (white). E. Qualitatively explain how you would histogram-equalise an RGB image. Would it improve or degrade the image? When histogram equalising an RGB image, you need to first separate the image into its 3 different parts; red, green, and blue. You would then carry out the equalisation 1 on each of these parts, and combine the product. Doing this would improve the image contrast. Alternatively, one can first convert the image to the HSV representation, and perform histogram equalisation on that. F. What are morphological image operators? Briefly dis- cuss image erosion, dilation, opening and closing. Morphological image operators carry out image processing based on shape [11]. A structuring element or kernel is used as a template. This results in a fit (all pixels of the kernel cover all pixels of object), hit (at least 1 pixel of the kernel covers a pixel of the object), and miss (no pixels of the kernel cover pixels of object). There are several methods: • Image erosion – Removes pixels from the outer layer of the object • Image dilation – Adds pixels around the outer layer of the object • Image opening – First carrying out image erosion and then dila- tion (separates out objects) • Image closing – First carrying out image dilation and then ero- sion (image repair) G. Briefly explain the differences between frequency and spatial domain filtering. • Frequency domain filtering [12] – Filters the frequencies of images for sharpening • Spatial domain filtering [13] – Filters the value of a pixel by comparing it to itself and surrounding pixels, this can be used to achieve image smoothing H. Identify and describe 3 methods of image segmentation. Discuss the importance of segmentation in medical image processing. Methods of image segmentation: [14] 1) Edge based • Finds the edges of objects. This can help identify features in the object 2) Region based • Divides the image into segments with similar characteristics. It does this by identifying seed points, and then growing or shrinking regions based on whether anything matches the seed point. 3) Watershed • Treats an image as a topographical map of pixel brightness. This forms ’watershed lines’ from formed ridges and basins Segmentation is an essential technique in isolating incon- sistencies in medical scans, and also enhancing patient scans like MRI. It allows us to not rely on the image itself for interpretation of what is wrong within the scan. I. Explain the terms correlation and convolution and how they are used in image and signal processing. • Correlation [15] – Correlation shows how much similarity exists between signals or an images. It can be used to compare it to itself to find shorter irregularities within the longer signal • Convolution – The combination of 2 signals or images. In signal processing this can be used to study LTI systems and design filters. In image processing this can be used along with a kernel or convolution matrix for applications like edge detection, and image sharpening and blurring. J. Briefly explain unfiltered back-projection. Describe a possible application for this in medical image processing. • Back projection [16] records how well pixels of an inputted image fit a histogram model. It is used in image segmentation, and finding objects in an image. It essentially identifies which colours in the inputted image belong to a specific object. • In medical imaging, back projection (filtered or unfil- tered) is used in CT scans to reconstruct the image from the x-ray data. Unfiltered back projection is used in PET scans to reconstruct the image from the gamma ray data. This can be used to find things like tumours and other medical irregularities. III. Practical This section will outline the steps taken to process the images provided, in order to identify the malaria infected cells. The assignment was carried out in Python [17], and makes use of several image processing techniques: unfil- tered back-projection, image contouring, binary thresh- olding, histogram equalisation, conversion between image representations, and various morphological operators. The images were taken from image set BBBC041v1, available from the Broad Bioimage Benchmark Collection [18], [19] A. Libraries Two (2) different libraries were used in the algorithm: OpenCV [20], and Matplotlib [21]. OpenCV was used to carry out the image processing, allowing for implementation of the techniques mentioned above, and outputting images at each stage of processing, in a grid-like fashion of all twelve (12) images. This was used in order to better evaluate the algorithm visually, without having to rerun it for each image individually, as can be seen in Appendix A. Matplotlib was used for plotting the example malaria cell’s image histogram. 2 B. Pre-processing The pre-processing stage involved three (3) steps: 1) Creation of an image of an isolated malaria-infected cell This was done using a screen-capture tool and then using a website called ’removebg’ [22], in order to not have any artifacts from the background in the soon to be created image histogram. This could have been done with image processing in code, but was deemed a trivial starting point. A cell from figure 22(image 11) was chosen: Fig. 1: Malaria Sample Cell 2) Loading in of images into variables that OpenCV can use. See appendix A-C. 3) Conversion of the images into the HSV represen- tation, this must be done in order to create a single-channel image histogram from the example cell, and thereafter use unfiltered back-projection on the images. The code for this can be found in appendix A-D. In figure 2 we can already see the sites of infection very clearly, and this can capitalised on using unfiltered back-projection. Fig. 2: Input grid of images converted to HSV (from image 1 top left to image 12 bottom right) C. Processing The processing stage involved the following: 1) Calculating the example malaria cell (figure 1) image histogram and equalising it. The code can be found in appendix A-E. Fig. 3: Malaria cell histogram, appropriately equalised to increase infected cell saturation 2) Applying unfiltered back-projection using the malaria cell histogram (figure 3) Fig. 4: Grid of unfiltered back-projection images, displaying the increase in saturation of infected cell colours in the form of a thresholded image 3) The third (3rd) step is to convert our HSV image into a grey-scale image, so that we can take a binary threshold in the next step Fig. 5: Grid of images converted to grey-scale 4) Now we apply a binary threshold, in order to later use morphological image operators. 3 Fig. 6: Grid display the binary thresholded images 5) We now carry out a sequence of morphological image operators, in order to (a) filter out noise, and (b) create whole cell shapes. Fig. 7: First stage of morphological opening. Note the distinct lack of image noise compared to figure 5 Fig. 8: Morphological closing, creating whole shapes Fig. 9: Final morphological operation, reducing the possible false positives and ensuring clarity of the images D. Post-processing Now for the final stage of developing the algorithm, to use the mask created in section III-C to display the found cells in a user/clinician friendly manner. In order to do this, two (2) steps are taken: 1) Finding the contours of each shape in figure 9. The code for this can be found in appendix ??. 2) Next is drawing the contours onto the original im- ages. This is a trivial step, but the code can be found in appendix A-J. Fig. 10: Final output grid of the images, for more clarity, refer to appendix B-B. E. Summary of process flow Now that the process of designing the algorithm has been discussed in detail, a process flow diagram will bring together the concepts. See figure 11. IV. Explanation of key code functions Several functions made this code possible, and their pur- pose and implementation will be explained here. A. Custom function The only custom function that was used is seen in ap- pendix A-B. This is taken from GeeksForGeeks [23], and allows the creation of the image grids throughout the paper. It makes use of OpenCV’s built-in vertical and horizontal concat functions. B. OpenCV functions • cv2.cvtColor [24] Used for converting between image representations. • cv2.calcHist [25] Used for creating the malaria sample cell image his- togram. • cv2.calcBackProject [16] Carries out the back-projection. • cv2.bitwise_and [26] Used for combining images, especially useful for ap- plying a mask made through other techniques onto an image. • cv2.threshold [27] Used to carry out the binary thresholding. 4 Fig. 11: Process diagram of the algorithm design process • cv2.morphologyEx [28] Used for all morphological operations, such as opening and closing • cv2.findContours [29] Used to find the contours of the shapes created in the algorithm V. Results and Discussion Out of the twenty-four (24) cells identified, twenty-three (23) were malaria-infected. The false positive was due to an overlapping of cells, causing a colour density similar to that of an infected cell, and due to the method of back- projection used in this algorithm, is unavoidable without significantly harming other results. This therefore indi- cates a 95.8 percent (%) efficacy rate. In the future, other segmentation methods could be implemented, in order to separate out overlapping cells (watershed segmentation methods were attempted to no avail). The addition of a neural net with many more samples would also provide a more reliable method of detection. VI. Conclusion This report answered theory questions involved in the basic understanding of digital image processing, and there- after walked through the process of creating the algorithm that identified the malaria-infected erythrocytes. The al- gorithm was found to have a 95.8 percent (%) efficacy rate, and other suggestions for improvement were made. References [1] D. Rubin, “Digital image processing project 2023,” May 2023. https://ulwazi.wits.ac.za/courses/49010/pages/ image-processing-assignment-2023?module_item_id=548343. [2] “Rgb color model.” https://simple.wikipedia.org/wiki/RGB_ color_model. [3] “The hsv color model in graphic design.” https://www.lifewire. com/what-is-hsv-in-design-1078068. [4] “Binary images.” https://homepages.inf.ed.ac.uk/rbf/ CVonline/LOCAL_COPIES/OWENS/LECT2/node3.html. [5] “Grayscale.” https://en.wikipedia.org/wiki/Grayscale. [6] “What is indexed image in image processing?.” https:// short-fact.com/what-is-indexed-image-in-image-processing/. [7] “Image licensing explained: Secure your rights with licensed photos now!.” https://blog.stockphotos.com/ image-licensing-explained/. [8] ramswarupkulhary, “Histogram of an image.” https://www. geeksforgeeks.org/histogram-of-an-image/. [9] O. team, “Histogram equalization.” https://docs.opencv.org/3. 4/d4/d1b/tutorial_histogram_equalization.html. [10] “Thresholding.” https://scikit-image.org/docs/stable/auto_ examples/applications/plot_thresholding_guide.html. [11] P. Chhikara, “Understanding morphological image processing and its operations.” https://towardsdatascience.com/ understanding-morphological-image-processing-and-its-operations-7bcf1ed11756. [12] pp pankaj, “Frequency domain filters and its types.” https://www.geeksforgeeks.org/ frequency-domain-filters-and-its-types/. [13] “Image processing 101 chapter 2.3: Spatial filters (convolution).” https://www.dynamsoft.com/blog/insights/image-processing/ image-processing-101-spatial-filters-convolution/. [14] “What is image segmentation?.” https://www.analytixlabs.co. in/blog/what-is-image-segmentation/. [15] CarloTomasi, “Imagecorrelation,convolutionandfiltering.” https://courses.cs.duke.edu/fall15/compsci527/notes/ convolution-filtering.pdf. [16] O. team, “Back projection.” https://docs.opencv.org/3.4/da/ d7f/tutorial_back_projection.html. [17] P. S. Foundation, “Python 3.11.3 documentation,” 2001-2023. https://docs.python.org/3/. [18] V. Ljosa, K. Sokolnicki, and A. Carpenter, “Annotated high-throughput microscopy image sets for validation.,” Na- ture Methods, 2012. https://www.nature.com/articles/nmeth. 2083#citeas. [19] V. Ljosa, K. Sokolnicki, and A. Carpenter, “Image set bbbc041v1 - broad bioimage benchmark collection,” 2012. https: //bbbc.broadinstitute.org/BBBC041/. 5 [20] O. team, “Opencv modules,” 2023. https://docs.opencv.org/4. 7.0/. [21] T. M. development team., “Matplotlib 3.7.1 documentation,” 2012-2023. https://matplotlib.org/stable/index.html. [22] K. A. GmbH, “removebg,” 2023. https://www.remove.bg/. [23] divyanshu17bec1138, “Concatenate images using opencv in python.” https://www.geeksforgeeks.org/ concatenate-images-using-opencv-in-python/. [24] Rajnis09, “Python opencv | cv2.cvtcolor() method.” https:// www.geeksforgeeks.org/python-opencv-cv2-cvtcolor-method/. [25] shahidedu7, “Python opencv – cv2.calchist method.” https:// www.geeksforgeeks.org/python-opencv-cv2-calchist-method/. [26] rishabhsingh1304, “Arithmetic operations on im- ages using opencv | set-2 (bitwise operations on binary images).” https://www.geeksforgeeks.org/ arithmetic-operations-on-images-using-opencv-set-2-bitwise-operations-on-binary-images/. [27] O. team, “Image thresholding.” https://docs.opencv.org/3.4/ d7/d4d/tutorial_py_thresholding.html. [28] O. team, “Morphological transformations.” https://docs. opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html. [29] O. team, “Contours : Getting started.” https://docs.opencv. org/4.x/d4/d73/tutorial_py_contours_begin.html. [30] tushardhiman1999, “Adding borders to the images using python – opencv.” https://www.geeksforgeeks.org/ adding-borders-to-the-images-using-python-opencv/. 6 Appendix A Code A. Imports 1 import matplotlib . pyplot as plt 2 import cv2 B. Special function to concatenate images 1 def concat ( list2d ) : 2 return cv2 . vconcat ([ cv2 . hconcat ( listh ) for listh in list2d ]) C. Reading in of images 1 image1 = cv2 . imread ( ’./ images / Image1 . png ’) 2 image2 = cv2 . imread ( ’./ images / Image2 . png ’) 3 image3 = cv2 . imread ( ’./ images / Image3 . png ’) 4 image4 = cv2 . imread ( ’./ images / Image4 . png ’) 5 image5 = cv2 . imread ( ’./ images / Image5 . png ’) 6 image6 = cv2 . imread ( ’./ images / Image6 . png ’) 7 image7 = cv2 . imread ( ’./ images / Image7 . png ’) 8 image8 = cv2 . imread ( ’./ images / Image8 . png ’) 9 image9 = cv2 . imread ( ’./ images / Image9 . png ’) 10 image10 = cv2 . imread ( ’./ images / Image10 . png ’) 11 image11 = cv2 . imread ( ’./ images / Image11 . png ’) 12 image12 = cv2 . imread ( ’./ images / Image12 . png ’) 13 bordercolor = [0 , 0 , 0] 14 border_image1 = cv2 . copyMakeBorder ( image1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 15 border_image2 = cv2 . copyMakeBorder ( image2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 16 border_image3 = cv2 . copyMakeBorder ( image3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 17 border_image4 = cv2 . copyMakeBorder ( image4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 18 border_image5 = cv2 . copyMakeBorder ( image5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 19 border_image6 = cv2 . copyMakeBorder ( image6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 20 border_image7 = cv2 . copyMakeBorder ( image7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 21 border_image8 = cv2 . copyMakeBorder ( image8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 22 border_image9 = cv2 . copyMakeBorder ( image9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 23 border_image10 = cv2 . copyMakeBorder ( image10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 24 border_image11 = cv2 . copyMakeBorder ( image11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 25 border_image12 = cv2 . copyMakeBorder ( image12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 26 input_images = concat_vh ([[ border_image1 , border_image2 , border_image3 , border_image4 ] , [ border_image5 , border_image6 , border_image7 , border_image8 ] , [ border_image9 , border_image10 , border_image11 , border_image12 ]]) 27 cv2 . imwrite ( ’./ images / input_images . png ’ , input_images ) 28 malaria_cell = cv2 . imread ( ’./ images / malaria - sample1 . png ’) 29 cv2 . imwrite ( ’./ images / malaria_cell . png ’ , malaria_cell ) D. Conversion to HSV 1 malaria_cell_hsv = cv2 . cvtColor ( malaria_cell , cv2 . COLOR_BGR2HSV ) 2 cv2 . imwrite ( ’./ images / malaria_cell_hsv . png ’ , malaria_cell_hsv ) 3 image1_hsv = cv2 . cvtColor ( image1 , cv2 . COLOR_BGR2HSV ) 4 image2_hsv = cv2 . cvtColor ( image2 , cv2 . COLOR_BGR2HSV ) 5 image3_hsv = cv2 . cvtColor ( image3 , cv2 . COLOR_BGR2HSV ) 6 image4_hsv = cv2 . cvtColor ( image4 , cv2 . COLOR_BGR2HSV ) 7 image5_hsv = cv2 . cvtColor ( image5 , cv2 . COLOR_BGR2HSV ) 8 image6_hsv = cv2 . cvtColor ( image6 , cv2 . COLOR_BGR2HSV ) 9 image7_hsv = cv2 . cvtColor ( image7 , cv2 . COLOR_BGR2HSV ) 10 image8_hsv = cv2 . cvtColor ( image8 , cv2 . COLOR_BGR2HSV ) 11 image9_hsv = cv2 . cvtColor ( image9 , cv2 . COLOR_BGR2HSV ) 12 image10_hsv = cv2 . cvtColor ( image10 , cv2 . COLOR_BGR2HSV ) 13 image11_hsv = cv2 . cvtColor ( image11 , cv2 . COLOR_BGR2HSV ) 14 image12_hsv = cv2 . cvtColor ( image12 , cv2 . COLOR_BGR2HSV ) 15 bo rder _im age 1_h sv = cv2 . copyMakeBorder ( image1_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 16 bo rder _im age 2_h sv = cv2 . copyMakeBorder ( image2_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 17 bo rder _im age 3_h sv = cv2 . copyMakeBorder ( image3_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 18 bo rder _im age 4_h sv = cv2 . copyMakeBorder ( image4_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 19 bo rder _im age 5_h sv = cv2 . copyMakeBorder ( image5_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 20 bo rde r_i mage 6_h sv = cv2 . copyMakeBorder ( image6_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) i 21 bo rder _im age 7_h sv = cv2 . copyMakeBorder ( image7_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 22 bo rder _im age 8_h sv = cv2 . copyMakeBorder ( image8_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 23 bo rde r_i mage 9_h sv = cv2 . copyMakeBorder ( image9_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 24 b or de r _i m ag e1 0 _h sv = cv2 . copyMakeBorder ( image10_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 25 b or de r _i m ag e1 1 _h sv = cv2 . copyMakeBorder ( image11_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 26 b or de r _i m ag e1 2 _h sv = cv2 . copyMakeBorder ( image12_hsv , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 27 hsv_images = concat_vh ([[ border_image1_hsv , border_image2_hsv , border_image3_hsv , bo rde r_i mag e4_h sv ] , [ border_image5_hsv , border_image6_hsv , border_image7_hsv , b ord er_i mag e8_ hsv ] , [ border_image9_hsv , border_image10_hsv , border_image11_hsv , b or d er _i m ag e1 2 _h s v ]]) 28 cv2 . imwrite ( ’./ images / hsv_images . png ’ , hsv_images ) E. Calculation of malaria cell image histogram 1 hsv_channels = [1 , 0] 2 histo_ranges = [0 , 196 , 56 , 196] 3 m a l a r i a _ c e l l _ h i s t o g r a m = cv2 . calcHist ([ malaria_cell_hsv ] , hsv_channels , None , [5 , 5] , histo_ranges ) 4 cv2 . normalize ( malaria_cell_histogram , malaria_cell_histogram , 0 , 255 , cv2 . NORM_MINMAX ) 5 plot = plt . hist ( m a l a r i a _ c e l l _ h i s t o g r a m ) 6 plt . savefig ( ’./ images / m a l a r i a _ c e l l _ h i s t o g r a m . png ’) F. Back-projection 1 scale = 5 2 b a c k p r o j e c t i o n _ m a s k 1 = cv2 . calcBackProject ([ image1_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 3 b a c k p r o j e c t i o n _ m a s k 2 = cv2 . calcBackProject ([ image2_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 4 b a c k p r o j e c t i o n _ m a s k 3 = cv2 . calcBackProject ([ image3_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 5 b a c k p r o j e c t i o n _ m a s k 4 = cv2 . calcBackProject ([ image4_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 6 b a c k p r o j e c t i o n _ m a s k 5 = cv2 . calcBackProject ([ image5_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 7 b a c k p r o j e c t i o n _ m a s k 6 = cv2 . calcBackProject ([ image6_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 8 b a c k p r o j e c t i o n _ m a s k 7 = cv2 . calcBackProject ([ image7_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 9 b a c k p r o j e c t i o n _ m a s k 8 = cv2 . calcBackProject ([ image8_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 10 b a c k p r o j e c t i o n _ m a s k 9 = cv2 . calcBackProject ([ image9_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 11 b a c k p r o j e c t i o n _ m a s k 1 0 = cv2 . calcBackProject ([ image10_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 12 b a c k p r o j e c t i o n _ m a s k 1 1 = cv2 . calcBackProject ([ image11_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 13 b a c k p r o j e c t i o n _ m a s k 1 2 = cv2 . calcBackProject ([ image12_hsv ] , hsv_channels , malaria_cell_histogram , histo_ranges , scale ) 14 i m a g e 1 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image1_hsv , image1_hsv , mask = b a c k p r o j e c t i o n _ m a s k 1 ) 15 i m a g e 2 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image2_hsv , image2_hsv , mask = b a c k p r o j e c t i o n _ m a s k 2 ) 16 i m a g e 3 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image3_hsv , image3_hsv , mask = b a c k p r o j e c t i o n _ m a s k 3 ) 17 i m a g e 4 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image4_hsv , image4_hsv , mask = b a c k p r o j e c t i o n _ m a s k 4 ) 18 i m a g e 5 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image5_hsv , image5_hsv , mask = b a c k p r o j e c t i o n _ m a s k 5 ) 19 i m a g e 6 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image6_hsv , image6_hsv , mask = b a c k p r o j e c t i o n _ m a s k 6 ) 20 i m a g e 7 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image7_hsv , image7_hsv , mask = b a c k p r o j e c t i o n _ m a s k 7 ) 21 i m a g e 8 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image8_hsv , image8_hsv , mask = b a c k p r o j e c t i o n _ m a s k 8 ) 22 i m a g e 9 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image9_hsv , image9_hsv , mask = b a c k p r o j e c t i o n _ m a s k 9 ) 23 i m a g e 1 0 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image10_hsv , image10_hsv , mask = b a c k p r o j e c t i o n _ m a s k 1 0 ) 24 i m a g e 1 1 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image11_hsv , image11_hsv , mask = b a c k p r o j e c t i o n _ m a s k 1 1 ) 25 i m a g e 1 2 _ b a c k p r o j e c t i o n = cv2 . bitwise_and ( image12_hsv , image12_hsv , mask = b a c k p r o j e c t i o n _ m a s k 1 2 ) 26 bordercolor = [255 , 255 , 255] 27 b o r d e r _ i m a g e 1 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image1_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 28 b o r d e r _ i m a g e 2 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image2_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 29 b o r d e r _ i m a g e 3 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image3_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 30 b o r d e r _ i m a g e 4 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image4_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 31 b o r d e r _ i m a g e 5 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image5_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) ii 32 b o r d e r _ i m a g e 6 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image6_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 33 b o r d e r _ i m a g e 7 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image7_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 34 b o r d e r _ i m a g e 8 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image8_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 35 b o r d e r _ i m a g e 9 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image9_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 36 b o r d e r _ i m a g e 1 0 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image10_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 37 b o r d e r _ i m a g e 1 1 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image11_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 38 b o r d e r _ i m a g e 1 2 _ b a c k p r o j e c t i o n = cv2 . copyMakeBorder ( image12_backprojection , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 39 backprojection = concat_vh ([[ border_image1_backprojection , border_image2_backprojection , border_image3_backprojection , b o r d e r _ i m a g e 4 _ b a c k p r o j e c t i o n ] , [ border_image5_backprojection , border_image6_backprojection , border_image7_backprojection , b o r d e r _ i m a g e 8 _ b a c k p r o j e c t i o n ] , [ border_image9_backprojection , border_image10_backprojection , border_image11_backprojection , b o r d e r _ i m a g e 1 2 _ b a c k p r o j e c t i o n ]]) 40 cv2 . imwrite ( ’./ images / backprojection . png ’ , backprojection ) G. Conversion back to RGB and subsequently to grey-scale 1 image1_bgr = cv2 . cvtColor ( image1_backprojection , cv2 . COLOR_HSV2BGR ) 2 image2_bgr = cv2 . cvtColor ( image2_backprojection , cv2 . COLOR_HSV2BGR ) 3 image3_bgr = cv2 . cvtColor ( image3_backprojection , cv2 . COLOR_HSV2BGR ) 4 image4_bgr = cv2 . cvtColor ( image4_backprojection , cv2 . COLOR_HSV2BGR ) 5 image5_bgr = cv2 . cvtColor ( image5_backprojection , cv2 . COLOR_HSV2BGR ) 6 image6_bgr = cv2 . cvtColor ( image6_backprojection , cv2 . COLOR_HSV2BGR ) 7 image7_bgr = cv2 . cvtColor ( image7_backprojection , cv2 . COLOR_HSV2BGR ) 8 image8_bgr = cv2 . cvtColor ( image8_backprojection , cv2 . COLOR_HSV2BGR ) 9 image9_bgr = cv2 . cvtColor ( image9_backprojection , cv2 . COLOR_HSV2BGR ) 10 image10_bgr = cv2 . cvtColor ( image10_backprojection , cv2 . COLOR_HSV2BGR ) 11 image11_bgr = cv2 . cvtColor ( image11_backprojection , cv2 . COLOR_HSV2BGR ) 12 image12_bgr = cv2 . cvtColor ( image12_backprojection , cv2 . COLOR_HSV2BGR ) 13 grey1 = cv2 . cvtColor ( image1_bgr , cv2 . COLOR_BGR2GRAY ) 14 grey2 = cv2 . cvtColor ( image2_bgr , cv2 . COLOR_BGR2GRAY ) 15 grey3 = cv2 . cvtColor ( image3_bgr , cv2 . COLOR_BGR2GRAY ) 16 grey4 = cv2 . cvtColor ( image4_bgr , cv2 . COLOR_BGR2GRAY ) 17 grey5 = cv2 . cvtColor ( image5_bgr , cv2 . COLOR_BGR2GRAY ) 18 grey6 = cv2 . cvtColor ( image6_bgr , cv2 . COLOR_BGR2GRAY ) 19 grey7 = cv2 . cvtColor ( image7_bgr , cv2 . COLOR_BGR2GRAY ) 20 grey8 = cv2 . cvtColor ( image8_bgr , cv2 . COLOR_BGR2GRAY ) 21 grey9 = cv2 . cvtColor ( image9_bgr , cv2 . COLOR_BGR2GRAY ) 22 grey10 = cv2 . cvtColor ( image10_bgr , cv2 . COLOR_BGR2GRAY ) 23 grey11 = cv2 . cvtColor ( image11_bgr , cv2 . COLOR_BGR2GRAY ) 24 grey12 = cv2 . cvtColor ( image12_bgr , cv2 . COLOR_BGR2GRAY ) 25 border_grey1 = cv2 . copyMakeBorder ( grey1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 26 border_grey2 = cv2 . copyMakeBorder ( grey2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 27 border_grey3 = cv2 . copyMakeBorder ( grey3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 28 border_grey4 = cv2 . copyMakeBorder ( grey4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 29 border_grey5 = cv2 . copyMakeBorder ( grey5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 30 border_grey6 = cv2 . copyMakeBorder ( grey6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 31 border_grey7 = cv2 . copyMakeBorder ( grey7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 32 border_grey8 = cv2 . copyMakeBorder ( grey8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 33 border_grey9 = cv2 . copyMakeBorder ( grey9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 34 border_grey10 = cv2 . copyMakeBorder ( grey10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 35 border_grey11 = cv2 . copyMakeBorder ( grey11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 36 border_grey12 = cv2 . copyMakeBorder ( grey12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 37 grey_images = concat_vh ([[ border_grey1 , border_grey2 , border_grey3 , border_grey4 ] , [ border_grey5 , border_grey6 , border_grey7 , border_grey8 ] , [ border_grey9 , border_grey10 , border_grey11 , border_grey12 ]]) 38 cv2 . imwrite ( ’./ images / grey_images . png ’ , grey_images ) H. Binary thresholding 1 thresh_values = [0 ,255] 2 threshold1 = cv2 . threshold ( grey1 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 3 threshold2 = cv2 . threshold ( grey2 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 4 threshold3 = cv2 . threshold ( grey3 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 5 threshold4 = cv2 . threshold ( grey4 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] iii 6 threshold5 = cv2 . threshold ( grey5 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 7 threshold6 = cv2 . threshold ( grey6 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 8 threshold7 = cv2 . threshold ( grey7 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 9 threshold8 = cv2 . threshold ( grey8 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 10 threshold9 = cv2 . threshold ( grey9 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 11 threshold10 = cv2 . threshold ( grey10 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 12 threshold11 = cv2 . threshold ( grey11 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 13 threshold12 = cv2 . threshold ( grey12 , thresh_values [0] , thresh_values [1] , cv2 . THRESH_BINARY + cv2 . THRESH_OTSU ) [1] 14 bo rder _th res hol d1 = cv2 . copyMakeBorder ( threshold1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 15 bo rder _th res hol d2 = cv2 . copyMakeBorder ( threshold2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 16 bo rder _th res hol d3 = cv2 . copyMakeBorder ( threshold3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 17 bo rder _th res hol d4 = cv2 . copyMakeBorder ( threshold4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 18 bo rder _th res hol d5 = cv2 . copyMakeBorder ( threshold5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 19 bo rde r_t hres hol d6 = cv2 . copyMakeBorder ( threshold6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 20 bo rder _th res hol d7 = cv2 . copyMakeBorder ( threshold7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 21 bo rder _th res hol d8 = cv2 . copyMakeBorder ( threshold8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 22 bo rde r_t hres hol d9 = cv2 . copyMakeBorder ( threshold9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 23 b or de r _t h re sh o ld 10 = cv2 . copyMakeBorder ( threshold10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 24 b or de r _t h re sh o ld 11 = cv2 . copyMakeBorder ( threshold11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 25 b or de r _t h re sh o ld 12 = cv2 . copyMakeBorder ( threshold12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 26 bi nary _th res hol ds = concat_vh ([[ border_threshold1 , border_threshold2 , border_threshold3 , bo rde r_th res hol d4 ] , [ border_threshold5 , border_threshold6 , border_threshold7 , bor der_ thr esh old8 ] , [ border_threshold9 , border_threshold10 , border_threshold11 , b or d er _t h re sh o ld 1 2 ]]) 27 cv2 . imwrite ( ’./ images / b inar y_t hre shol ds . png ’ , b ina ry_ thr esho lds ) I. Morphological operations 1 kernel = cv2 . g e t S t r u c t u r i n g E l e m e n t ( cv2 . MORPH_ELLIPSE , (7 , 7) ) 2 op ened _th res hol d1 = cv2 . morphologyEx ( threshold1 , cv2 . MORPH_OPEN , kernel ) 3 op ened _th res hol d2 = cv2 . morphologyEx ( threshold2 , cv2 . MORPH_OPEN , kernel ) 4 op ened _th res hol d3 = cv2 . morphologyEx ( threshold3 , cv2 . MORPH_OPEN , kernel ) 5 op ened _th res hol d4 = cv2 . morphologyEx ( threshold4 , cv2 . MORPH_OPEN , kernel ) 6 op ened _th res hol d5 = cv2 . morphologyEx ( threshold5 , cv2 . MORPH_OPEN , kernel ) 7 op ene d_t hres hol d6 = cv2 . morphologyEx ( threshold6 , cv2 . MORPH_OPEN , kernel ) 8 op ened _th res hol d7 = cv2 . morphologyEx ( threshold7 , cv2 . MORPH_OPEN , kernel ) 9 op ened _th res hol d8 = cv2 . morphologyEx ( threshold8 , cv2 . MORPH_OPEN , kernel ) 10 op ene d_t hres hol d9 = cv2 . morphologyEx ( threshold9 , cv2 . MORPH_OPEN , kernel ) 11 o pe ne d _t h re sh o ld 10 = cv2 . morphologyEx ( threshold10 , cv2 . MORPH_OPEN , kernel ) 12 o pe ne d _t h re sh o ld 11 = cv2 . morphologyEx ( threshold11 , cv2 . MORPH_OPEN , kernel ) 13 o pe ne d _t h re sh o ld 12 = cv2 . morphologyEx ( threshold12 , cv2 . MORPH_OPEN , kernel ) 14 b o r d e r _ o p e n e d _ t h r e s h o l d 1 = cv2 . copyMakeBorder ( opened_threshold1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 15 b o r d e r _ o p e n e d _ t h r e s h o l d 2 = cv2 . copyMakeBorder ( opened_threshold2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 16 b o r d e r _ o p e n e d _ t h r e s h o l d 3 = cv2 . copyMakeBorder ( opened_threshold3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 17 b o r d e r _ o p e n e d _ t h r e s h o l d 4 = cv2 . copyMakeBorder ( opened_threshold4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 18 b o r d e r _ o p e n e d _ t h r e s h o l d 5 = cv2 . copyMakeBorder ( opened_threshold5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 19 b o r d e r _ o p e n e d _ t h r e s h o l d 6 = cv2 . copyMakeBorder ( opened_threshold6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 20 b o r d e r _ o p e n e d _ t h r e s h o l d 7 = cv2 . copyMakeBorder ( opened_threshold7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 21 b o r d e r _ o p e n e d _ t h r e s h o l d 8 = cv2 . copyMakeBorder ( opened_threshold8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) iv 22 b o r d e r _ o p e n e d _ t h r e s h o l d 9 = cv2 . copyMakeBorder ( opened_threshold9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 23 b o r d e r _ o p e n e d _ t h r e s h o l d 1 0 = cv2 . copyMakeBorder ( opened_threshold10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 24 b o r d e r _ o p e n e d _ t h r e s h o l d 1 1 = cv2 . copyMakeBorder ( opened_threshold11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 25 b o r d e r _ o p e n e d _ t h r e s h o l d 1 2 = cv2 . copyMakeBorder ( opened_threshold12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 26 first_opens = concat_vh ([[ border_opened_threshold1 , border_opened_threshold2 , border_opened_threshold3 , b o r d e r _ o p e n e d _ t h r e s h o l d 4 ] , [ border_opened_threshold5 , border_opened_threshold6 , border_opened_threshold7 , b o r d e r _ o p e n e d _ t h r e s h o l d 8 ] , [ border_opened_threshold9 , border_opened_threshold10 , border_opened_threshold11 , b o r d e r _ o p e n e d _ t h r e s h o l d 1 2 ]]) 27 cv2 . imwrite ( ’./ images / first_opens . png ’ , first_opens ) 28 kernel = cv2 . g e t S t r u c t u r i n g E l e m e n t ( cv2 . MORPH_ELLIPSE , (70 , 70) ) 29 iterations = 2 30 cl osed _th res hol d1 = cv2 . morphologyEx ( opened_threshold1 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 31 cl osed _th res hol d2 = cv2 . morphologyEx ( opened_threshold2 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 32 cl osed _th res hol d3 = cv2 . morphologyEx ( opened_threshold3 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 33 cl osed _th res hol d4 = cv2 . morphologyEx ( opened_threshold4 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 34 cl osed _th res hol d5 = cv2 . morphologyEx ( opened_threshold5 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 35 cl ose d_t hres hol d6 = cv2 . morphologyEx ( opened_threshold6 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 36 cl osed _th res hol d7 = cv2 . morphologyEx ( opened_threshold7 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 37 cl osed _th res hol d8 = cv2 . morphologyEx ( opened_threshold8 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 38 cl ose d_t hres hol d9 = cv2 . morphologyEx ( opened_threshold9 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 39 c lo se d _t h re sh o ld 10 = cv2 . morphologyEx ( opened_threshold10 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 40 c lo se d _t h re sh o ld 11 = cv2 . morphologyEx ( opened_threshold11 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 41 c lo se d _t h re sh o ld 12 = cv2 . morphologyEx ( opened_threshold12 , cv2 . MORPH_CLOSE , kernel , iterations = iterations ) 42 b o r d e r _ c l o s e d _ t h r e s h o l d 1 = cv2 . copyMakeBorder ( closed_threshold1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 43 b o r d e r _ c l o s e d _ t h r e s h o l d 2 = cv2 . copyMakeBorder ( closed_threshold2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 44 b o r d e r _ c l o s e d _ t h r e s h o l d 3 = cv2 . copyMakeBorder ( closed_threshold3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 45 b o r d e r _ c l o s e d _ t h r e s h o l d 4 = cv2 . copyMakeBorder ( closed_threshold4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 46 b o r d e r _ c l o s e d _ t h r e s h o l d 5 = cv2 . copyMakeBorder ( closed_threshold5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 47 b o r d e r _ c l o s e d _ t h r e s h o l d 6 = cv2 . copyMakeBorder ( closed_threshold6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 48 b o r d e r _ c l o s e d _ t h r e s h o l d 7 = cv2 . copyMakeBorder ( closed_threshold7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 49 b o r d e r _ c l o s e d _ t h r e s h o l d 8 = cv2 . copyMakeBorder ( closed_threshold8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 50 b o r d e r _ c l o s e d _ t h r e s h o l d 9 = cv2 . copyMakeBorder ( closed_threshold9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 51 b o r d e r _ c l o s e d _ t h r e s h o l d 1 0 = cv2 . copyMakeBorder ( closed_threshold10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 52 b o r d e r _ c l o s e d _ t h r e s h o l d 1 1 = cv2 . copyMakeBorder ( closed_threshold11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 53 b o r d e r _ c l o s e d _ t h r e s h o l d 1 2 = cv2 . copyMakeBorder ( closed_threshold12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 54 cl osed _th res hol ds = concat_vh ([[ border_closed_threshold1 , border_closed_threshold2 , border_closed_threshold3 , b o r d e r _ c l o s e d _ t h r e s h o l d 4 ] , [ border_closed_threshold5 , border_closed_threshold6 , border_closed_threshold7 , b o r d e r _ c l o s e d _ t h r e s h o l d 8 ] , [ border_closed_threshold9 , border_closed_threshold10 , border_closed_threshold11 , b o r d e r _ c l o s e d _ t h r e s h o l d 1 2 ]]) 55 cv2 . imwrite ( ’./ images / c lose d_t hre shol ds . png ’ , c los ed_ thr esho lds ) 56 kernel = cv2 . g e t S t r u c t u r i n g E l e m e n t ( cv2 . MORPH_ELLIPSE , (30 , 30) ) 57 r e o p e ne d _ t h r e s ho l d 1 = cv2 . morphologyEx ( closed_threshold1 , cv2 . MORPH_OPEN , kernel ) 58 r e o p e ne d _ t h r e s ho l d 2 = cv2 . morphologyEx ( closed_threshold2 , cv2 . MORPH_OPEN , kernel ) 59 r e o p e ne d _ t h r e s ho l d 3 = cv2 . morphologyEx ( closed_threshold3 , cv2 . MORPH_OPEN , kernel ) 60 r e o p e ne d _ t h r e s ho l d 4 = cv2 . morphologyEx ( closed_threshold4 , cv2 . MORPH_OPEN , kernel ) 61 r e o p e ne d _ t h r e s ho l d 5 = cv2 . morphologyEx ( closed_threshold5 , cv2 . MORPH_OPEN , kernel ) 62 r e o p en e d _ t h r e s h ol d 6 = cv2 . morphologyEx ( closed_threshold6 , cv2 . MORPH_OPEN , kernel ) v 63 r e o p e ne d _ t h r e s ho l d 7 = cv2 . morphologyEx ( closed_threshold7 , cv2 . MORPH_OPEN , kernel ) 64 r e o p e ne d _ t h r e s ho l d 8 = cv2 . morphologyEx ( closed_threshold8 , cv2 . MORPH_OPEN , kernel ) 65 r e o p en e d _ t h r e s h ol d 9 = cv2 . morphologyEx ( closed_threshold9 , cv2 . MORPH_OPEN , kernel ) 66 r e o p e n e d _ t h r e s h o l d 1 0 = cv2 . morphologyEx ( closed_threshold10 , cv2 . MORPH_OPEN , kernel ) 67 r e o p e n e d _ t h r e s h o l d 1 1 = cv2 . morphologyEx ( closed_threshold11 , cv2 . MORPH_OPEN , kernel ) 68 r e o p e n e d _ t h r e s h o l d 1 2 = cv2 . morphologyEx ( closed_threshold12 , cv2 . MORPH_OPEN , kernel ) 69 b o r d e r _ r e o p e n e d _ t h r e s h o l d 1 = cv2 . copyMakeBorder ( reopened_threshold1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 70 b o r d e r _ r e o p e n e d _ t h r e s h o l d 2 = cv2 . copyMakeBorder ( reopened_threshold2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 71 b o r d e r _ r e o p e n e d _ t h r e s h o l d 3 = cv2 . copyMakeBorder ( reopened_threshold3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 72 b o r d e r _ r e o p e n e d _ t h r e s h o l d 4 = cv2 . copyMakeBorder ( reopened_threshold4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 73 b o r d e r _ r e o p e n e d _ t h r e s h o l d 5 = cv2 . copyMakeBorder ( reopened_threshold5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 74 b o r d e r _ r e o p e n e d _ t h r e s h o l d 6 = cv2 . copyMakeBorder ( reopened_threshold6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 75 b o r d e r _ r e o p e n e d _ t h r e s h o l d 7 = cv2 . copyMakeBorder ( reopened_threshold7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 76 b o r d e r _ r e o p e n e d _ t h r e s h o l d 8 = cv2 . copyMakeBorder ( reopened_threshold8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 77 b o r d e r _ r e o p e n e d _ t h r e s h o l d 9 = cv2 . copyMakeBorder ( reopened_threshold9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 78 b o r d e r _ r e o p e n e d _ t h r e s h o l d 1 0 = cv2 . copyMakeBorder ( reopened_threshold10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 79 b o r d e r _ r e o p e n e d _ t h r e s h o l d 1 1 = cv2 . copyMakeBorder ( reopened_threshold11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 80 b o r d e r _ r e o p e n e d _ t h r e s h o l d 1 2 = cv2 . copyMakeBorder ( reopened_threshold12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 81 r e o p e ne d _ t h r e s ho l d s = concat_vh ([[ border_reopened_threshold1 , border_reopened_threshold2 , border_reopened_threshold3 , b o r d e r _ r e o p e n e d _ t h r e s h o l d 4 ] , [ border_reopened_threshold5 , border_reopened_threshold6 , border_reopened_threshold7 , b o r d e r _ r e o p e n e d _ t h r e s h o l d 8 ] , [ border_reopened_threshold9 , border_reopened_threshold10 , border_reopened_threshold11 , b o r d e r _ r e o p e n e d _ t h r e s h o l d 1 2 ]]) 82 cv2 . imwrite ( ’./ images / r e op e n e d _ t h r es h o l d s . png ’ , r e o p e n e d _ th r e s h o l d s ) J. Drawing contours onto output 1 colour = (0 , 255 , 0) 2 thickness = 10 3 output1 = cv2 . drawContours ( image1 , contours1 , -1 , colour , thickness ) 4 output2 = cv2 . drawContours ( image2 , contours2 , -1 , colour , thickness ) 5 output3 = cv2 . drawContours ( image3 , contours3 , -1 , colour , thickness ) 6 output4 = cv2 . drawContours ( image4 , contours4 , -1 , colour , thickness ) 7 output5 = cv2 . drawContours ( image5 , contours5 , -1 , colour , thickness ) 8 output6 = cv2 . drawContours ( image6 , contours6 , -1 , colour , thickness ) 9 output7 = cv2 . drawContours ( image7 , contours7 , -1 , colour , thickness ) 10 output8 = cv2 . drawContours ( image8 , contours8 , -1 , colour , thickness ) 11 output9 = cv2 . drawContours ( image9 , contours9 , -1 , colour , thickness ) 12 output10 = cv2 . drawContours ( image10 , contours10 , -1 , colour , thickness ) 13 output11 = cv2 . drawContours ( image11 , contours11 , -1 , colour , thickness ) 14 output12 = cv2 . drawContours ( image12 , contours12 , -1 , colour , thickness ) 15 bordercolor = [0 , 0 , 0] 16 border_output1 = cv2 . copyMakeBorder ( output1 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 17 border_output2 = cv2 . copyMakeBorder ( output2 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 18 border_output3 = cv2 . copyMakeBorder ( output3 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 19 border_output4 = cv2 . copyMakeBorder ( output4 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 20 border_output5 = cv2 . copyMakeBorder ( output5 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 21 border_output6 = cv2 . copyMakeBorder ( output6 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 22 border_output7 = cv2 . copyMakeBorder ( output7 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 23 border_output8 = cv2 . copyMakeBorder ( output8 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 24 border_output9 = cv2 . copyMakeBorder ( output9 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 25 border_output10 = cv2 . copyMakeBorder ( output10 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 26 border_output11 = cv2 . copyMakeBorder ( output11 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 27 border_output12 = cv2 . copyMakeBorder ( output12 , 5 , 5 , 5 , 5 , cv2 . BORDER_CONSTANT , value = bordercolor ) 28 output_images = concat_vh ([[ border_output1 , border_output2 , border_output3 , border_output4 ] , [ border_output5 , border_output6 , border_output7 , border_output8 ] , [ border_output9 , border_output10 , border_output11 , border_output12 ]]) 29 cv2 . imwrite (\"./ images / output_images . png \" , output_images ) vi Appendix B Images A. Input images Fig. 12: Image 1 Fig. 13: Image 2 Fig. 14: Image 3 Fig. 15: Image 4 Fig. 16: Image 5 Fig. 17: Image 6 vii Fig. 18: Image 7 Fig. 19: Image 8 Fig. 20: Image 9 Fig. 21: Image 10 Fig. 22: Image 11 Fig. 23: Image 12 viii B. Output images Fig. 24: Output 1 Fig. 25: Output 2 Fig. 26: Output 3 Fig. 27: Output 4 Fig. 28: Output 5 Fig. 29: Output 6 ix Fig. 30: Output 7 Fig. 31: Output 8 Fig. 32: Output 9 Fig. 33: Output 10 Fig. 34: Output 11 Fig. 35: Output 12 x C. Image grids Fig. 36: Input grid Fig. 37: HSV grid Fig. 38: Back-projection grid xi Fig. 39: Grey grid Fig. 40: Binary threshold grid Fig. 41: First open grid xii Fig. 42: Closed grid Fig. 43: Reopened grid Fig. 44: Output grid xiii","libVersion":"0.2.2","langs":""}